//! JavaScript/WASM Bindings Scaffold
//!
//! This module provides documentation and utilities for using oxiz-wasm from JavaScript/TypeScript.
//! It includes:
//! - TypeScript type definition generation
//! - Usage examples and documentation
//! - Integration guidance for web applications
//!
//! # Using OxiZ in JavaScript/TypeScript
//!
//! The `oxiz-wasm` crate provides WebAssembly bindings for the OxiZ SMT solver.
//! This allows you to run SMT solving directly in the browser or Node.js.
//!
//! ## Installation
//!
//! ```bash
//! npm install oxiz-wasm
//! # or
//! yarn add oxiz-wasm
//! ```
//!
//! ## Basic Usage (JavaScript)
//!
//! ```javascript
//! import init, { WasmSolver } from 'oxiz-wasm';
//!
//! async function solveSMT() {
//!     // Initialize the WASM module
//!     await init();
//!
//!     // Create a solver instance
//!     const solver = new WasmSolver();
//!
//!     // Set the logic
//!     solver.setLogic("QF_LIA");
//!
//!     // Declare variables
//!     solver.declareConst("x", "Int");
//!     solver.declareConst("y", "Int");
//!
//!     // Add constraints
//!     solver.assertFormula("(> x 0)");
//!     solver.assertFormula("(< y 10)");
//!     solver.assertFormula("(= (+ x y) 15)");
//!
//!     // Check satisfiability
//!     const result = solver.checkSat();
//!     console.log("Result:", result); // "sat" or "unsat"
//!
//!     if (result === "sat") {
//!         const model = solver.getModel();
//!         console.log("Model:", model);
//!     }
//! }
//! ```
//!
//! ## TypeScript Usage
//!
//! ```typescript
//! import init, { WasmSolver, WasmErrorKind } from 'oxiz-wasm';
//!
//! interface SMTModel {
//!     [key: string]: {
//!         name: string;
//!         sort: string;
//!         value: string | number | boolean;
//!     };
//! }
//!
//! async function solveSMT(): Promise<SMTModel | null> {
//!     await init();
//!     const solver = new WasmSolver();
//!
//!     try {
//!         solver.setLogic("QF_LIA");
//!         solver.declareConst("x", "Int");
//!         solver.assertFormula("(> x 0)");
//!
//!         const result = solver.checkSat();
//!         if (result === "sat") {
//!             return solver.getModel() as SMTModel;
//!         }
//!         return null;
//!     } catch (error: any) {
//!         if (error.kind === WasmErrorKind.ParseError) {
//!             console.error("Parse error:", error.message);
//!         }
//!         throw error;
//!     }
//! }
//! ```
//!
//! ## React Integration Example
//!
//! ```typescript
//! import { useState, useEffect } from 'react';
//! import init, { WasmSolver } from 'oxiz-wasm';
//!
//! function SMTSolverComponent() {
//!     const [solver, setSolver] = useState<WasmSolver | null>(null);
//!     const [result, setResult] = useState<string>("");
//!
//!     useEffect(() => {
//!         async function initSolver() {
//!             await init();
//!             setSolver(new WasmSolver());
//!         }
//!         initSolver();
//!     }, []);
//!
//!     const handleSolve = () => {
//!         if (!solver) return;
//!
//!         solver.setLogic("QF_LIA");
//!         solver.declareConst("x", "Int");
//!         solver.assertFormula("(> x 0)");
//!
//!         const res = solver.checkSat();
//!         setResult(res);
//!     };
//!
//!     return (
//!         <div>
//!             <button onClick={handleSolve}>Solve</button>
//!             <p>Result: {result}</p>
//!         </div>
//!     );
//! }
//! ```
//!
//! # CLI Integration
//!
//! Use `--generate-wasm-types` to generate TypeScript type definitions:
//!
//! ```bash
//! oxiz --generate-wasm-types > oxiz-types.d.ts
//! ```

use std::fs;
use std::path::Path;

/// TypeScript type definitions for oxiz-wasm
///
/// These type definitions document the WASM API for TypeScript users.
pub const TYPESCRIPT_TYPES: &str = r#"// OxiZ WASM TypeScript Type Definitions
// Generated by oxiz-cli --generate-wasm-types

/**
 * Error kinds returned by WASM operations
 */
export enum WasmErrorKind {
    /** Parse error in SMT-LIB2 script */
    ParseError = "ParseError",
    /** Invalid sort name */
    InvalidSort = "InvalidSort",
    /** No model available (check-sat not called or result was unsat) */
    NoModel = "NoModel",
    /** No unsat core available */
    NoUnsatCore = "NoUnsatCore",
    /** No proof available */
    NoProof = "NoProof",
    /** Solver is in an invalid state for this operation */
    InvalidState = "InvalidState",
    /** Invalid input or argument */
    InvalidInput = "InvalidInput",
    /** Operation not supported */
    NotSupported = "NotSupported",
    /** Unknown error */
    Unknown = "Unknown",
}

/**
 * Error object returned by WASM operations
 */
export interface WasmError {
    /** Error type */
    kind: WasmErrorKind;
    /** Human-readable error message */
    message: string;
}

/**
 * Sort types supported by OxiZ
 */
export type Sort = "Bool" | "Int" | "Real" | `BitVec${number}` | string;

/**
 * Result of check-sat operation
 */
export type SatResult = "sat" | "unsat" | "unknown";

/**
 * Variable value in a model
 */
export interface ModelValue {
    /** Variable name */
    name: string;
    /** Variable sort */
    sort: Sort;
    /** Variable value (type depends on sort) */
    value: string | number | boolean | bigint;
}

/**
 * Model returned by getModel()
 */
export interface Model {
    [variableName: string]: ModelValue;
}

/**
 * Statistics returned by getStatistics()
 */
export interface Statistics {
    /** Number of decisions made */
    decisions: number;
    /** Number of conflicts encountered */
    conflicts: number;
    /** Number of propagations */
    propagations: number;
    /** Number of restarts */
    restarts: number;
    /** Time spent solving (milliseconds) */
    time_ms: number;
    /** Memory used (bytes) */
    memory_bytes: number;
}

/**
 * WASM-accessible SMT solver
 *
 * This is the main interface for using OxiZ from JavaScript/TypeScript.
 * It provides a high-level API for SMT solving operations.
 *
 * @example
 * ```typescript
 * import init, { WasmSolver } from 'oxiz-wasm';
 *
 * async function main() {
 *     await init();
 *     const solver = new WasmSolver();
 *     solver.setLogic("QF_LIA");
 *     solver.declareConst("x", "Int");
 *     solver.assertFormula("(> x 0)");
 *     const result = solver.checkSat();
 *     console.log(result); // "sat"
 * }
 * ```
 */
export class WasmSolver {
    /**
     * Create a new solver instance
     */
    constructor();

    /**
     * Free resources associated with this solver
     */
    free(): void;

    /**
     * Execute an SMT-LIB2 script and return the results
     * @param script - An SMT-LIB2 script string
     * @returns The output of the script execution
     * @throws {WasmError} If the script contains syntax errors or invalid commands
     */
    execute(script: string): string;

    /**
     * Set the logic for the solver
     * @param logic - The SMT-LIB2 logic name (e.g., "QF_LIA", "QF_BV", "ALL")
     */
    setLogic(logic: string): void;

    /**
     * Declare a constant with a given name and sort
     * @param name - The constant name
     * @param sort - The sort (type) of the constant
     * @throws {WasmError} If the name is empty or sort is invalid
     */
    declareConst(name: string, sort: Sort): void;

    /**
     * Declare a function with given name, parameter sorts, and return sort
     * @param name - The function name
     * @param paramSorts - Array of parameter sorts
     * @param returnSort - The return sort
     * @throws {WasmError} If declaration fails
     */
    declareFun(name: string, paramSorts: Sort[], returnSort: Sort): void;

    /**
     * Define a function with given name, parameters, return sort, and body
     * @param name - The function name
     * @param params - Array of [name, sort] pairs for parameters
     * @param returnSort - The return sort
     * @param body - The function body as an SMT-LIB2 expression
     * @throws {WasmError} If definition fails
     */
    defineFun(name: string, params: [string, Sort][], returnSort: Sort, body: string): void;

    /**
     * Assert a formula (add a constraint)
     * @param formula - An SMT-LIB2 formula to assert
     * @throws {WasmError} If the formula has syntax errors
     */
    assertFormula(formula: string): void;

    /**
     * Check satisfiability of the current assertions
     * @returns "sat", "unsat", or "unknown"
     */
    checkSat(): SatResult;

    /**
     * Check satisfiability under a set of assumptions
     * @param assumptions - Array of SMT-LIB2 boolean expressions to assume
     * @returns "sat", "unsat", or "unknown"
     * @throws {WasmError} If any assumption is invalid
     */
    checkSatAssuming(assumptions: string[]): SatResult;

    /**
     * Get the satisfying model (only valid after check-sat returns "sat")
     * @returns The model as a JavaScript object
     * @throws {WasmError} If no model is available
     */
    getModel(): Model;

    /**
     * Get the UNSAT core (only valid after check-sat returns "unsat")
     * @returns Array of assertion names in the UNSAT core
     * @throws {WasmError} If no UNSAT core is available
     */
    getUnsatCore(): string[];

    /**
     * Push a new assertion level (for incremental solving)
     * @param levels - Number of levels to push (default: 1)
     */
    push(levels?: number): void;

    /**
     * Pop assertion levels (for incremental solving)
     * @param levels - Number of levels to pop (default: 1)
     * @throws {WasmError} If trying to pop more levels than pushed
     */
    pop(levels?: number): void;

    /**
     * Reset the solver to its initial state
     */
    reset(): void;

    /**
     * Reset all assertions while keeping declarations
     */
    resetAssertions(): void;

    /**
     * Set a solver option
     * @param option - The option name
     * @param value - The option value
     */
    setOption(option: string, value: string): void;

    /**
     * Get solver statistics
     * @returns Statistics object with solver metrics
     */
    getStatistics(): Statistics;

    /**
     * Get info about the solver
     * @param keyword - The info keyword (e.g., ":name", ":version")
     * @returns The requested information
     */
    getInfo(keyword: string): string;

    /**
     * Cancel any running operation (for async usage)
     */
    cancel(): void;

    /**
     * Check if solver is in cancelled state
     */
    isCancelled(): boolean;

    /**
     * Clear the cancelled state
     */
    clearCancelled(): void;

    /**
     * Simplify an expression
     * @param expr - The expression to simplify
     * @returns The simplified expression
     * @throws {WasmError} If expression is invalid
     */
    simplify(expr: string): string;

    /**
     * Get assertions currently in the solver
     * @returns Array of assertion strings
     */
    getAssertions(): string[];
}

/**
 * Initialize the WASM module
 * Must be called before creating WasmSolver instances
 * @param input - Optional URL or buffer of the WASM module
 * @returns Promise that resolves when initialization is complete
 */
export default function init(input?: RequestInfo | URL | BufferSource): Promise<void>;
"#;

/// Generate TypeScript type definitions
#[allow(dead_code)]
pub fn generate_typescript_types() -> String {
    TYPESCRIPT_TYPES.to_string()
}

/// Write TypeScript type definitions to a file
#[allow(dead_code)]
pub fn write_typescript_types(path: &Path) -> Result<(), String> {
    fs::write(path, TYPESCRIPT_TYPES)
        .map_err(|e| format!("Failed to write TypeScript types: {}", e))
}

/// Example JavaScript code for basic usage
pub const EXAMPLE_JS_BASIC: &str = r#"// Basic OxiZ WASM Usage Example
// Run with: node --experimental-wasm-modules basic.mjs

import init, { WasmSolver } from 'oxiz-wasm';

async function main() {
    // Initialize WASM module
    await init();

    // Create solver
    const solver = new WasmSolver();

    // Set logic (Quantifier-Free Linear Integer Arithmetic)
    solver.setLogic("QF_LIA");

    // Declare integer variables
    solver.declareConst("x", "Int");
    solver.declareConst("y", "Int");

    // Add constraints
    solver.assertFormula("(> x 0)");          // x > 0
    solver.assertFormula("(< y 100)");        // y < 100
    solver.assertFormula("(= (+ x y) 50)");   // x + y = 50

    // Check satisfiability
    const result = solver.checkSat();
    console.log("Result:", result);

    if (result === "sat") {
        // Get satisfying model
        const model = solver.getModel();
        console.log("Model:", JSON.stringify(model, null, 2));

        // Access individual values
        console.log("x =", model.x.value);
        console.log("y =", model.y.value);
    }

    // Clean up
    solver.free();
}

main().catch(console.error);
"#;

/// Example JavaScript code for incremental solving
pub const EXAMPLE_JS_INCREMENTAL: &str = r#"// Incremental Solving with OxiZ WASM
// Demonstrates push/pop for exploring multiple scenarios

import init, { WasmSolver } from 'oxiz-wasm';

async function main() {
    await init();
    const solver = new WasmSolver();

    solver.setLogic("QF_LIA");
    solver.declareConst("x", "Int");
    solver.declareConst("y", "Int");

    // Base constraints
    solver.assertFormula("(>= x 0)");
    solver.assertFormula("(>= y 0)");
    solver.assertFormula("(<= (+ x y) 100)");

    console.log("Base constraints: x >= 0, y >= 0, x + y <= 100");

    // Scenario 1: x > 50
    solver.push();
    solver.assertFormula("(> x 50)");
    console.log("\nScenario 1 (x > 50):", solver.checkSat());
    if (solver.checkSat() === "sat") {
        const model = solver.getModel();
        console.log("  x =", model.x.value, ", y =", model.y.value);
    }
    solver.pop();

    // Scenario 2: y > 80
    solver.push();
    solver.assertFormula("(> y 80)");
    console.log("\nScenario 2 (y > 80):", solver.checkSat());
    if (solver.checkSat() === "sat") {
        const model = solver.getModel();
        console.log("  x =", model.x.value, ", y =", model.y.value);
    }
    solver.pop();

    // Scenario 3: Both x > 60 and y > 60 (should be unsat)
    solver.push();
    solver.assertFormula("(> x 60)");
    solver.assertFormula("(> y 60)");
    console.log("\nScenario 3 (x > 60 and y > 60):", solver.checkSat());
    solver.pop();

    solver.free();
}

main().catch(console.error);
"#;

/// Example TypeScript code with error handling
pub const EXAMPLE_TS_ERROR_HANDLING: &str = r#"// TypeScript Example with Error Handling

import init, { WasmSolver, WasmErrorKind } from 'oxiz-wasm';

interface OxiZError {
    kind: string;
    message: string;
}

async function solveSafely(script: string): Promise<{
    success: boolean;
    result?: string;
    error?: OxiZError;
}> {
    await init();
    const solver = new WasmSolver();

    try {
        const result = solver.execute(script);
        return { success: true, result };
    } catch (error: unknown) {
        const oxizError = error as OxiZError;

        // Handle specific error types
        switch (oxizError.kind) {
            case WasmErrorKind.ParseError:
                console.error("Syntax error in SMT-LIB2 script");
                break;
            case WasmErrorKind.InvalidInput:
                console.error("Invalid input provided");
                break;
            default:
                console.error("Solver error:", oxizError.message);
        }

        return { success: false, error: oxizError };
    } finally {
        solver.free();
    }
}

// Usage
async function main() {
    // Valid script
    const validScript = `
        (set-logic QF_LIA)
        (declare-const x Int)
        (assert (> x 0))
        (check-sat)
        (get-model)
    `;

    console.log("Testing valid script:");
    const result1 = await solveSafely(validScript);
    console.log(result1);

    // Invalid script (syntax error)
    const invalidScript = `
        (set-logic QF_LIA)
        (declare-const x Int)
        (assert (> x))  ; Missing operand
        (check-sat)
    `;

    console.log("\nTesting invalid script:");
    const result2 = await solveSafely(invalidScript);
    console.log(result2);
}

main().catch(console.error);
"#;

/// Example for bitvector operations
pub const EXAMPLE_JS_BITVECTORS: &str = r#"// Bitvector Operations with OxiZ WASM
// Useful for hardware verification and low-level programming

import init, { WasmSolver } from 'oxiz-wasm';

async function main() {
    await init();
    const solver = new WasmSolver();

    // Quantifier-Free Bitvector logic
    solver.setLogic("QF_BV");

    // Declare 32-bit bitvectors
    solver.declareConst("x", "(_ BitVec 32)");
    solver.declareConst("y", "(_ BitVec 32)");
    solver.declareConst("result", "(_ BitVec 32)");

    // Add constraints
    // x AND y = result
    solver.assertFormula("(= (bvand x y) result)");

    // x = 0xFFFF0000
    solver.assertFormula("(= x #xFFFF0000)");

    // y = 0x0F0F0F0F
    solver.assertFormula("(= y #x0F0F0F0F)");

    // Check and get model
    const satResult = solver.checkSat();
    console.log("Result:", satResult);

    if (satResult === "sat") {
        const model = solver.getModel();
        console.log("x =", model.x.value);
        console.log("y =", model.y.value);
        console.log("x AND y =", model.result.value);
        // Expected: 0x0F0F0000
    }

    solver.free();
}

main().catch(console.error);
"#;

/// Get all example code snippets
#[allow(dead_code)]
pub fn get_all_examples() -> Vec<(&'static str, &'static str)> {
    vec![
        ("basic.mjs", EXAMPLE_JS_BASIC),
        ("incremental.mjs", EXAMPLE_JS_INCREMENTAL),
        ("error_handling.ts", EXAMPLE_TS_ERROR_HANDLING),
        ("bitvectors.mjs", EXAMPLE_JS_BITVECTORS),
    ]
}

/// Write example files to a directory
#[allow(dead_code)]
pub fn write_examples(dir: &Path) -> Result<(), String> {
    fs::create_dir_all(dir).map_err(|e| format!("Failed to create examples directory: {}", e))?;

    for (filename, content) in get_all_examples() {
        let path = dir.join(filename);
        fs::write(&path, content).map_err(|e| format!("Failed to write {}: {}", filename, e))?;
    }

    Ok(())
}

/// Format WASM integration help message
#[allow(dead_code)]
pub fn format_wasm_help() -> String {
    r#"OxiZ WASM Integration Guide
============================

The oxiz-wasm crate provides WebAssembly bindings for using OxiZ in browsers and Node.js.

Installation:
  npm install oxiz-wasm

Usage in JavaScript:
  import init, { WasmSolver } from 'oxiz-wasm';

  await init();
  const solver = new WasmSolver();
  solver.setLogic("QF_LIA");
  solver.declareConst("x", "Int");
  solver.assertFormula("(> x 0)");
  console.log(solver.checkSat()); // "sat"

Generate TypeScript types:
  oxiz --generate-wasm-types > oxiz.d.ts

For more examples, see:
  oxiz --examples

Documentation:
  https://docs.rs/oxiz-wasm
"#
    .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_typescript_types() {
        let types = generate_typescript_types();
        assert!(types.contains("export class WasmSolver"));
        assert!(types.contains("export enum WasmErrorKind"));
        assert!(types.contains("checkSat(): SatResult"));
    }

    #[test]
    fn test_get_all_examples() {
        let examples = get_all_examples();
        assert!(!examples.is_empty());
        assert!(examples.iter().any(|(name, _)| *name == "basic.mjs"));
    }

    #[test]
    fn test_write_typescript_types() {
        let path = std::path::PathBuf::from("/tmp/oxiz_test_types.d.ts");
        let result = write_typescript_types(&path);
        assert!(result.is_ok());

        let contents = fs::read_to_string(&path).unwrap();
        assert!(contents.contains("WasmSolver"));

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn test_write_examples() {
        let dir = std::path::PathBuf::from("/tmp/oxiz_test_examples");
        let _ = fs::remove_dir_all(&dir);

        let result = write_examples(&dir);
        assert!(result.is_ok());

        assert!(dir.join("basic.mjs").exists());
        assert!(dir.join("incremental.mjs").exists());
        assert!(dir.join("error_handling.ts").exists());
        assert!(dir.join("bitvectors.mjs").exists());

        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn test_format_wasm_help() {
        let help = format_wasm_help();
        assert!(help.contains("npm install oxiz-wasm"));
        assert!(help.contains("WasmSolver"));
    }
}
